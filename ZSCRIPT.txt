// Weapons
#include "Actors/Weapons/RogueSpecial.txt"
#include "Actors/Weapons/Railgun.txt"
// Items
#include "Actors/Items/BouncyBullets.txt"
#include "Actors/Items/ScatterBullets.txt"
#include "Actors/Items/FlakBullets.txt"
#include "Actors/Items/SnowBullets.txt"
#include "Actors/Items/StoutBullets.txt"
#include "Actors/Items/GhostBullets.txt"
#include "Actors/Items/PlusOneBullets.txt"
#include "Actors/Items/FatBullets.txt"
// Other
#include "Actors/Weapons/Projectiles/CustomProjectile.txt"

Class Gungeoneer : Doomplayer
{
	Default 
	{
		Player.StartItem "RogueSpecial";
		Player.StartItem "RogueSpecialAmmo", 8;
	}
}

Class Pilot : Gungeoneer
{
	Default 
	{
		Player.StartItem "RogueSpecial";
		Player.StartItem "RogueSpecialAmmo", 8;
	}
}


Class ProjectileBase : CustomProjectile 
{
	float DamageModifier;
	float _BaseDamageModifier;
	float _SnowBulletsDamageModifier; // Increases over time
	float _StoutBulletsDamageModifier; // Decreases over time
	float _GhostBulletsDamageModifier; // Halves with each rip, only relevant for GhostBullets though
	
	// These are documented in Default {}
	int ScatterCount;
	property ScatterCount: ScatterCount;
	float ScatterDamage;
	property ScatterDamage: ScatterDamage;
	
	int FlakCount;
	property FlakCount: FlakCount;
	float FlakDamage;
	property FlakDamage: FlakDamage;
	
	float BaseDamage;
	property BaseDamage: BaseDamage;
	
	int PierceCount;
	int _StoredPierceCount;
	property PierceCount: PierceCount;
	
	int DamageCooldown;
	int _StoredDamageCooldown;
	property DamageCooldown: DamageCooldown;
	
	bool IsStout;
	property IsStout: IsStout;
	bool IsSnowball;
	property IsSnowball: IsSnowball;

	action void A_FireScatterBullets()
	{
		if(master != null) return; // Real bullets have no masters
		int count = CountInv("ScatterBullets", AAPTR_PLAYER1) + invoker.ScatterCount;
		for(int i = 0; i < count; ++i)
		{
			// TODO: Circular scatter pattern (now it's a square pattern)
			Vector3 t = Pos + Vel / Speed + (frandom(-0.2, 0.2), frandom(-0.2, 0.2), frandom(-0.2, 0.2));
			Vector3 dir = t - Pos;
			if(dir.Length() != 0) {
				dir /= dir.Length();
			}
			dir *= Speed;
			
			A_SpawnItemEx(
				invoker.GetClassName(), 
				0, 0, 0, 
				dir.x, dir.y, dir.z, Angle, 
				SXF_SETMASTER | SXF_ISTARGET | SXF_ABSOLUTEANGLE | SXF_ABSOLUTEVELOCITY | SXF_NOCHECKPOSITION 
			);
			let proj = ProjectileBase(target);
			if(invoker.ScatterDamage > 0) {
				proj._BaseDamageModifier = invoker.ScatterDamage;
			}
			else {
				proj._BaseDamageModifier = 1.0 / count;
			}
		}
	}
	
	action void A_FireFlakBullets() // TODO: Maybe deduplicate with A_FireScatterBullets?
	{
		if(master != null) return; // Real bullets have no masters
		int count = CountInv("FlakBullets", AAPTR_PLAYER1) + invoker.FlakCount;
		for(int i = 0; i < count; ++i)
		{
			Vector3 t = Pos + Vel / Speed + (frandom(-1, 1), frandom(-1, 1), frandom(-1, 1));
			Vector3 dir = t - Pos;
			if(dir.Length() != 0) {
				dir /= dir.Length();
			}
			dir *= Speed;
			
			A_SpawnItemEx(
				invoker.GetClassName(), 
				0, 0, 0, 
				dir.x, dir.y, dir.z, Angle, 
				SXF_SETMASTER  | SXF_ISTARGET | SXF_ABSOLUTEANGLE | SXF_ABSOLUTEVELOCITY | SXF_NOCHECKPOSITION 
			);
			let proj = ProjectileBase(target);
			if(invoker.FlakDamage > 0) {
				proj._BaseDamageModifier = invoker.FlakDamage;
			}
			else {
				proj._BaseDamageModifier = 1.0 / count;
			}
		}
	}
	
	// Handles passive items that affect bullets when they spawn. Ex. ScatterBullets.
	action void A_PostSpawn()
	{
		A_FireScatterBullets();
	}
	
	// Handles passive items that affect bullets when they die. Ex. FlakBullets.
	action void A_PreDeath()
	{
		A_SetScale(1); // Temporary fix for snowbullets creating huge death puffs.
		A_FireFlakBullets();
	}
	
	override void BeginPlay()
	{
		// _BaseDamageModifier can be already set if this is a secondary projectile from Scatter or Flak
		if(_BaseDamageModifier == 0) _BaseDamageModifier = 1;
		DamageModifier = 1;
		_SnowBulletsDamageModifier = 1;
		_GhostBulletsDamageModifier = 1;
		_StoutBulletsDamageModifier = 1; // See PostBeginPlay()
		_StoredDamageCooldown = 0;
		_StoredPierceCount = 0;
	}
	
    override void PostBeginPlay()
	{
		// This could be done in Tick() but it makes more sense for a bullet
		// to know how many times it should bounce only when it spawns
		BounceCount = CountInv("BouncyBullets", AAPTR_PLAYER1) + 1;
		PierceCount += CountInv("GhostBullets", AAPTR_PLAYER1);
		if(PierceCount > 0) {
			bRipper = true;
		}
		
		if(IsStout || CountInv("StoutBullets", AAPTR_PLAYER1) > 0) {
			A_SetScale(Scale.x * 4);
			_StoutBulletsDamageModifier = 4;
			Vel *= 0.7;
		}
		if(CountInv("FatBullets", AAPTR_PLAYER1) > 0) {
			A_SetScale(Scale.x * 2 * CountInv("FatBullets", AAPTR_PLAYER1));
		}
	}
	
	// Handles passive items that affect bullets as they travel. Ex. SnowBullets.
	override void Tick()
	{
		Super.Tick();
		
		// Rippers only deal damage when _StoredDamageCooldown is 0
		if(bRipper && _StoredDamageCooldown > 0)
		{
			_StoredDamageCooldown--;
		}
		
		bool hasSnowBullets = CountInv("SnowBullets", AAPTR_PLAYER1) > 0;
		if((hasSnowBullets || IsSnowball) && _SnowBulletsDamageModifier < 3)
		{
			A_SetScale(Scale.x * (1+4.0/35)); // Double every second
			_SnowBulletsDamageModifier *= (1 + 2.0/35);
		}
		bool hasStoutBullets = CountInv("StoutBullets", AAPTR_PLAYER1) > 0;
		if((hasStoutBullets || IsStout) && _StoutBulletsDamageModifier > 0.33)
		{
			A_SetScale(Scale.x * (1-4.0/35));
			_StoutBulletsDamageModifier *= (1 - 4.0/35);
		}
		
		DamageModifier = _BaseDamageModifier * _SnowBulletsDamageModifier * _GhostBulletsDamageModifier * _StoutBulletsDamageModifier;
		// One-off modifiers
		DamageModifier += 1.25 * DamageModifier * CountInv("PlusOneBullets", AAPTR_PLAYER1);
		DamageModifier += 1.30 * DamageModifier * CountInv("FatBullets", AAPTR_PLAYER1);
		// TODO: Fat Bullets should increase knockback but knockback is yet to be implemented fully
		A_Print(""..DamageModifier);
	}
	
	// Overrides damage calculations when hitting monsters to account for modifiers
	override int SpecialMissileHit(Actor victim)
	{
		if(!victim.bIsMonster || !victim.bShootable || !victim.bSolid) return Super.SpecialMissileHit(victim);
	
		// Rippers in Doom have a low damage and continuously inflict it
		// If DamageCooldown is > 0 (default is 2), rippers can deal arbitrary damage
		// but it will only be dealt once every DamageCooldown tics.
		// Example: A laser beam that inflicts damage every .5 seconds should set DamageCooldown to 35/2=17 tics.
		if(bRipper)
		{
			if(_StoredDamageCooldown != 0) {
				return 1;
			}
			if(PierceCount > 0 && ++_StoredPierceCount > PierceCount) {
				bRipper = false;
				return 0;
			}
			// Ghost bullets damage halving should apply after this projectile's innate pierces
			if(_StoredPierceCount > abs(PierceCount - CountInv("GhostBullets", AAPTR_PLAYER1))) {
				_GhostBulletsDamageModifier *= 0.5;
			}
			_StoredDamageCooldown = DamageCooldown;
		}
		victim.A_DamageSelf((BaseDamage * DamageModifier), "DtgDamage");
		return bRipper ? 1 : 0; // -1 = Missile should die, 0 = It should explode, 1 = It should continue
	}
	
	Default 
	{
		Projectile;
		// Bouncing is handled a bit differently as CustomProjectile is a special
		// implementation of FastProjectile. Hexen's bounce type implies
		// that projectiles bounce on floors and walls as far as flags are concerned.
		BounceType "Hexen";
		// 1 = Doesn't bounce. 0 or less = Bounces forever.
		BounceCount 1;
		// Attenuation when bouncing off of ceilings and floors
		BounceFactor 1;
		// Attenuation when bouncing off of walls
		WallBounceFactor 1;
		// If > 0 fires copies of this projectile in a scattershot pattern when spawning
		ProjectileBase.ScatterCount 0;
		// If < 0, damage is BaseDamage/ScatterCount. Otherwise, damage is BaseDamage * ScatterDamage.
		ProjectileBase.ScatterDamage -1;
		// If > 0 explodes in copies of this projectile upon death
		ProjectileBase.FlakCount 0;
		// If < 0, damage is BaseDamage/FlakCount. Otherwise, damage is BaseDamage * FlakDamage.
		ProjectileBase.FlakDamage -1;
		// Since Damage and DamageFunction are wonky, they are not used and BaseDamage is used instead.
		ProjectileBase.BaseDamage 0;
		// If PierceCount > 0 the projectile becomes +RIPPER automatically and rips through PierceCount enemies, then loses the flag.
		ProjectileBase.PierceCount 0;
		DamageFunction (1); // Hack to bypass IsZeroDamage()
		// If the projectile is +RIPPER, this property makes it so that it only deals damage every X tics. < 1 to disable.
		// 2 is enough to prevent double-hits on imps with the railgun but an eye should be kept on this default.
		ProjectileBase.DamageCooldown 2;
		
		ProjectileBase.IsStout false;
		ProjectileBase.IsSnowball false;
	}
}

Class ItemBase : Inventory 
{
	Default 
	{
		Inventory.Amount 1;
		Inventory.MaxAmount 999;
		+INVENTORY.PERSISTENTPOWER;
	}
}

class WeaponBase : Weapon 
{
	// TODO: FatBullets should reduce max ammo by 10%
}